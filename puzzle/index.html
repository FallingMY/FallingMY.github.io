<!DOCTYPE html>
<html>
<head>
    <title>Puzzle</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sixtyfour|Press+Start+2P">
</head>
<body>
    <div id="bg_logo">
        <p id="logo_p">Falling_Studio</p>
    </div>
    <div id="puzzle">
        <a href="RE/log001.html" class="puzzle_1_a" id="log1">
            <p class="puzzle_1_p_hidden">Log001</p>
        </a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        // GSAP 动画部分保持不变
        window.onload = function() {
            gsap.from(".puzzle_1_a", {
                duration: 0.8,
                y: 50,
                opacity: 0,
                ease: "power2.out",
                delay: 0.4,
            });
            gsap.from("#puzzle", {
                duration: 0.8,
                opacity: 0,
                delay: 0.2,
            });

            let bg = document.getElementById("puzzle");
            let log1 = document.getElementById("log1");

            log1.addEventListener("mouseover", function() {
                gsap.to(bg, {
                    duration: 0.5,
                    backgroundColor: "#0A0C16",
                });
            });

            log1.addEventListener("mouseout", function() {
                gsap.to(bg, {
                    duration: 0.5,
                    backgroundColor: "rgb(59, 59, 59)",
                });
            });
        };


        document.addEventListener('DOMContentLoaded',function(){
            // 获取所有带有特定 class 的p标签（这里我们暂时仍用这个选择器来初始化状态）
            const targetParagraphs = document.querySelectorAll('p.puzzle_1_p_hidden');

            // 存储每个p标签的原始文本、遮罩文本和定时器ID
            const paraStates = new Map();

            // 动画速度（每帧间隔毫秒）
            const ANIMATION_SPEED_MS = 30; 

            // 遍历每个需要动画的p标签，进行初始化设置
            targetParagraphs.forEach(p => {
                const originalText = p.textContent;
                const textLength = originalText.length;
                const maskText = '\\'.repeat(textLength); 

                // 初始化状态，基于p标签本身作为键
                paraStates.set(p,{
                    originalText: originalText,
                    maskText: maskText,
                    currentIntervalId: null, 
                    transitionIndex: 0, 
                });
                
                // 页面加载时，将p标签内容替换为反斜杠遮罩
                p.textContent = maskText;

                // *** 关键修改：获取p标签的父级a标签，并为其添加事件监听器 ***
                const parentA = p.closest('a'); // 查找最近的a祖先元素

                if (parentA) { // 确保找到了a标签
                    // 添加鼠标悬停事件监听器到a标签（正向揭示动画：从左到右）
                    parentA.addEventListener('mouseover',function(){
                        // 在a标签的事件中，找到其内部的p标签
                        const pTagToAnimate = this.querySelector('p.puzzle_1_p_hidden');
                        if (!pTagToAnimate) return; // 如果没找到p标签，则退出

                        const state = paraStates.get(pTagToAnimate); // 根据找到的p标签获取其状态

                        // 如果当前有动画正在进行，先清除它
                        if (state.currentIntervalId) {
                            clearInterval(state.currentIntervalId);
                        }

                        // 重置动画进度，从头开始揭示
                        state.transitionIndex = 0; 

                        // 启动新的揭示动画定时器
                        state.currentIntervalId = setInterval(() => {
                            if (state.transitionIndex < state.originalText.length) {
                                // 构造当前显示的字符串，并应用于pTagToAnimate
                                const revealedPart = state.originalText.substring(0, state.transitionIndex + 1);
                                const remainingMask = state.maskText.substring(state.transitionIndex + 1); 
                                pTagToAnimate.textContent = revealedPart + remainingMask; // 应用到正确的p标签
                                state.transitionIndex++;
                            } else {
                                // 所有字符都已揭示，动画完成
                                clearInterval(state.currentIntervalId);
                                state.currentIntervalId = null;
                                pTagToAnimate.textContent = state.originalText; // 确保最终显示完整的原文
                            }
                        }, ANIMATION_SPEED_MS); 
                    });

                    // 添加鼠标移开事件监听器到a标签（反向隐藏动画：从右到左）
                    parentA.addEventListener('mouseout',function(){
                        // 在a标签的事件中，找到其内部的p标签
                        const pTagToAnimate = this.querySelector('p.puzzle_1_p_hidden');
                        if (!pTagToAnimate) return; // 如果没找到p标签，则退出

                        const state = paraStates.get(pTagToAnimate); // 根据找到的p标签获取其状态

                        // 清除任何正在进行的动画（无论是揭示还是之前的隐藏动画）
                        if (state.currentIntervalId) {
                            clearInterval(state.currentIntervalId);
                        }

                        // 重置动画进度，从当前文本的最后一个字符（即最右侧）开始隐藏
                        state.transitionIndex = pTagToAnimate.textContent.length; 

                        // 启动新的隐藏动画定时器
                        state.currentIntervalId = setInterval(() => {
                            if (state.transitionIndex > 0) {
                                const leftOriginalPart = state.originalText.substring(0, state.transitionIndex - 1);
                                const rightMaskedPart = state.maskText.substring(state.transitionIndex - 1);
                                pTagToAnimate.textContent = leftOriginalPart + rightMaskedPart; // 应用到正确的p标签
                                state.transitionIndex--; 
                            } else {
                                // 所有字符都已变为反斜杠，动画完成
                                clearInterval(state.currentIntervalId);
                                state.currentIntervalId = null;
                                pTagToAnimate.textContent = state.maskText; // 确保最终显示完整的反斜杠遮罩
                            }
                        }, ANIMATION_SPEED_MS); 
                    });
                }
            });
        });
    </script>
</body>
</html>
